数学問題作成システム - 段階別実装計画
ご提示いただいた内容を整理し、実現可能な実装を段階別に作成しました。AIエージェントは最終段階に配置しています。

Phase 1: 基本変換システムの構築（1-2週間）
最初の段階では、HTMLからWord文書への基本的な変換機能を確立します。この段階で最も重要なのは、数式の画像化と統一されたスタイル適用の仕組みを作ることです。

実装する機能:

統一スタイル設定ファイルの作成により、すべての問題で一貫した見た目を保証します。設定ファイルには数式画像の解像度（DPI 300推奨）、フォントサイズ、色、テキストフォント（見出し・本文）、行間、余白などを定義します。

Copy# style_config.py
STYLE_CONFIG = {
    # 数式画像設定
    'math_dpi': 300,
    'math_font_size': 14,
    'math_color': 'black',
    'math_background': 'transparent',
    
    # テキストスタイル
    'title_font': 'MS Gothic',
    'title_size': 16,
    'title_bold': True,
    'body_font': 'MS Mincho',
    'body_size': 11,
    
    # レイアウト
    'problem_spacing': 1.5,
    'paragraph_spacing': 1.15,
    'page_margin': 2.54,  # cm
}
HTML解析モジュールでは、BeautifulSoupを使用してHTMLを解析し、問題構造（見出し、本文、数式、選択肢）を抽出します。数式部分は正規表現で$$...$$や\(...\)パターンを検出し、LaTeX文字列として保持します。

Copy# html_parser.py
from bs4 import BeautifulSoup
import re

class HTMLParser:
    def __init__(self):
        self.latex_pattern = re.compile(r'\$\$(.*?)\$\$|\\\((.*?)\\\)')
    
    def parse(self, html_content):
        soup = BeautifulSoup(html_content, 'html.parser')
        problems = []
        
        for problem_div in soup.find_all('div', class_='problem'):
            problem_data = {
                'title': self._extract_title(problem_div),
                'text': self._extract_text(problem_div),
                'equations': self._extract_equations(problem_div),
                'choices': self._extract_choices(problem_div)
            }
            problems.append(problem_data)
        
        return problems
数式画像化モジュールでは、matplotlibを使用してLaTeX数式を高品質なPNG画像に変換します。透過背景、アンチエイリアシング、適切な余白設定により、Word文書に挿入しても美しく表示されます。

Copy# math_converter.py
import matplotlib.pyplot as plt
from matplotlib import mathtext
from PIL import Image
import io

class MathConverter:
    def __init__(self, config):
        self.dpi = config['math_dpi']
        self.font_size = config['math_font_size']
        self.color = config['math_color']
    
    def latex_to_image(self, latex_str):
        """LaTeX数式を画像化"""
        fig = plt.figure(figsize=(0.01, 0.01))
        fig.text(0, 0, f'${latex_str}$',
                fontsize=self.font_size,
                color=self.color)
        
        # 高解像度で保存
        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=self.dpi,
                   bbox_inches='tight',
                   transparent=True,
                   pad_inches=0.1)
        plt.close()
        
        buf.seek(0)
        return buf
Word文書生成モジュールでは、python-docxを使用して統一されたスタイルでWord文書を作成します。大問番号の自動採番、統一されたフォント・サイズ適用、数式画像のインライン挿入を実装します。

成果物:

基本的なHTML→Word変換が動作
数式が画像として正しく挿入される
スタイル設定による統一感のある出力
Phase 2: 統一感強化とプロンプトテンプレート（1週間）
この段階では、複数の大問を作成する際の統一感を確保する仕組みを強化します。特にAIへのプロンプト設計が重要になります。

実装する機能:

構造化プロンプトテンプレートの作成により、AIが常に同じHTML構造で問題を生成するようにします。このテンプレートには厳密なタグ構造、クラス名の規則、数式記法の統一を含めます。

Copy# prompt_templates.py
PROBLEM_GENERATION_PROMPT = """
あなたは数学問題作成AIです。
以下の厳密なフォーマットで問題を生成してください。

【HTML構造】
<div class="problem">
  <h2 class="problem-title">大問[番号]</h2>
  <p class="problem-text">問題文をここに記述</p>
  <div class="math">$$LaTeX数式$$</div>
  <ol class="choices" type="1">
    <li>選択肢1</li>
    <li>選択肢2</li>
    <li>選択肢3</li>
    <li>選択肢4</li>
  </ol>
</div>

【数式記法の規則】
- インライン数式: \\(x^2\\)
- 独立数式: $$\\frac{{a}}{{b}}$$
- 必ずLaTeX記法を使用

【制約事項】
- HTMLタグはdiv, p, h2, ol, liのみ使用
- クラス名は必ず指定（problem, problem-title, problem-text, math, choices）
- 数式以外のスタイル指定は不要

【生成する問題の内容】
難易度: {difficulty}
分野: {category}
問題数: {count}
"""
複数問題の一括変換機能では、統一されたスタイルで複数の大問を処理します。大問番号の自動管理、問題間の適切な間隔設定、ページレイアウトの統一を実装します。

Copy# unified_converter.py
from docx import Document
from docx.shared import Pt, Cm

class UnifiedMathConverter:
    def __init__(self, style_config):
        self.config = style_config
        self.problem_counter = 0
    
    def convert_multiple_problems(self, html_list):
        """複数問題を統一スタイルで変換"""
        doc = Document()
        self._apply_global_style(doc)
        
        for html in html_list:
            self.problem_counter += 1
            self._add_problem(doc, html)
            
            # 大問間の間隔
            if self.problem_counter < len(html_list):
                doc.add_paragraph()
        
        return doc
    
    def _apply_global_style(self, doc):
        """文書全体のスタイル設定"""
        sections = doc.sections
        for section in sections:
            section.top_margin = Cm(self.config['page_margin'])
            section.bottom_margin = Cm(self.config['page_margin'])
            section.left_margin = Cm(self.config['page_margin'])
            section.right_margin = Cm(self.config['page_margin'])
    
    def _add_problem(self, doc, html):
        """統一フォーマットで大問を追加"""
        parsed = self.parser.parse(html)
        
        # 大問タイトル
        title = doc.add_heading(f'大問{self.problem_counter}', level=1)
        title_run = title.runs[0]
        title_run.font.name = self.config['title_font']
        title_run.font.size = Pt(self.config['title_size'])
        title_run.font.bold = self.config['title_bold']
        
        # 問題文と数式を追加
        # ...
プロンプトバリデーション機能では、生成されたHTMLが規定の構造に従っているかをチェックします。必須要素の存在確認、クラス名の検証、数式記法の確認を行い、不適切な場合は警告を出します。

成果物:

AIへの標準プロンプトテンプレート
複数大問の統一的な処理
HTML構造の検証機能
Phase 3: テンプレートシステムとGUI（1-2週間）
この段階では、用途別のテンプレート切り替えとユーザーインターフェースを実装します。

実装する機能:

テンプレート管理システムでは、問題集、小テスト、宿題など用途別のスタイルテンプレートを作成します。各テンプレートにはヘッダー・フッター設定、ページ番号形式、余白設定が含まれます。

Copy# template_manager.py
class TemplateManager:
    def __init__(self):
        self.templates = {
            'standard': {
                'name': '標準問題集',
                'header': None,
                'footer': 'ページ {page}',
                'title_style': '見出し 1',
                'numbering': True,
            },
            'exam': {
                'name': '定期試験',
                'header': '{school_name} 数学テスト',
                'footer': '氏名:__________ 得点:____/100',
                'title_style': '見出し 2',
                'time_limit': True,
            },
            'homework': {
                'name': '宿題プリント',
                'header': '提出日: {date}',
                'footer': 'クラス:____ 番号:____ 氏名:__________',
                'answer_space': True,
            }
        }
    
    def apply_template(self, doc, template_name, **kwargs):
        """テンプレートを文書に適用"""
        template = self.templates[template_name]
        
        # ヘッダー・フッター設定
        section = doc.sections[0]
        if template.get('header'):
            header = section.header
            header.paragraphs[0].text = template['header'].format(**kwargs)
        
        if template.get('footer'):
            footer = section.footer
            footer.paragraphs[0].text = template['footer'].format(**kwargs)
シンプルなGUIでは、Tkinterを使用して変換操作を行うインターフェースを作成します。HTMLファイルの選択、テンプレート選択、プレビュー表示、Word文書の保存機能を実装します。

Copy# gui.py
import tkinter as tk
from tkinter import filedialog, ttk
from tkinter import scrolledtext

class ConverterGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("数学問題変換システム")
        self.root.geometry("800x600")
        
        self._create_widgets()
        self.converter = UnifiedMathConverter(STYLE_CONFIG)
        self.template_manager = TemplateManager()
    
    def _create_widgets(self):
        # ファイル選択フレーム
        file_frame = ttk.Frame(self.root, padding="10")
        file_frame.grid(row=0, column=0, sticky=(tk.W, tk.E))
        
        ttk.Button(file_frame, text="HTMLファイル選択",
                  command=self.select_files).grid(row=0, column=0)
        
        self.file_label = ttk.Label(file_frame, text="ファイル未選択")
        self.file_label.grid(row=0, column=1, padx=10)
        
        # テンプレート選択
        template_frame = ttk.Frame(self.root, padding="10")
        template_frame.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        ttk.Label(template_frame, text="テンプレート:").grid(row=0, column=0)
        self.template_var = tk.StringVar(value='standard')
        template_menu = ttk.Combobox(template_frame,
                                     textvariable=self.template_var,
                                     values=['standard', 'exam', 'homework'])
        template_menu.grid(row=0, column=1, padx=10)
        
        # プレビューエリア
        preview_frame = ttk.LabelFrame(self.root, text="プレビュー", padding="10")
        preview_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=10, pady=10)
        
        self.preview_text = scrolledtext.ScrolledText(preview_frame, height=20)
        self.preview_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # 変換ボタン
        button_frame = ttk.Frame(self.root, padding="10")
        button_frame.grid(row=3, column=0)
        
        ttk.Button(button_frame, text="Word文書に変換",
                  command=self.convert).grid(row=0, column=0, padx=5)
        ttk.Button(button_frame, text="クリップボードにコピー",
                  command=self.copy_to_clipboard).grid(row=0, column=1, padx=5)
プレビュー機能では、変換結果を実際のWord文書に近い形で表示します。数式画像のサムネイル表示、レイアウトの確認が可能です。

成果物:

用途別テンプレートシステム
使いやすいGUI
プレビュー・クリップボード機能
Phase 4: バッチ処理と自動化（1週間）
この段階では、大量の問題を効率的に処理する機能を追加します。

実装する機能:

バッチ変換機能では、フォルダ内の複数HTMLファイルを一括処理します。処理の進捗表示、エラーハンドリング、ログ出力を実装します。

Copy# batch_processor.py
import os
from pathlib import Path
import logging

class BatchProcessor:
    def __init__(self, converter, template_manager):
        self.converter = converter
        self.template_manager = template_manager
        self.logger = self._setup_logger()
    
    def process_folder(self, input_folder, output_folder, template='standard'):
        """フォルダ内のHTMLファイルを一括変換"""
        html_files = list(Path(input_folder).glob('*.html'))
        total = len(html_files)
        
        self.logger.info(f"処理開始: {total}ファイル")
        
        for i, html_file in enumerate(html_files, 1):
            try:
                self.logger.info(f"処理中 ({i}/{total}): {html_file.name}")
                
                # HTML読み込み
                with open(html_file, 'r', encoding='utf-8') as f:
                    html_content = f.read()
                
                # Word文書生成
                doc = self.converter.convert_multiple_problems([html_content])
                self.template_manager.apply_template(doc, template)
                
                # 保存
                output_path = Path(output_folder) / f"{html_file.stem}.docx"
                doc.save(str(output_path))
                
                self.logger.info(f"完了: {output_path}")
                
            except Exception as e:
                self.logger.error(f"エラー ({html_file.name}): {str(e)}")
        
        self.logger.info("すべての処理が完了しました")
フォルダ監視機能では、watchdogライブラリを使用して指定フォルダを監視し、新しいHTMLファイルが追加されたら自動的に変換します。

Copy# folder_watcher.py
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class HTMLFileHandler(FileSystemEventHandler):
    def __init__(self, converter, output_folder, template):
        self.converter = converter
        self.output_folder = output_folder
        self.template = template
    
    def on_created(self, event):
        if event.is_directory:
            return
        
        if event.src_path.endswith('.html'):
            print(f"新しいファイル検出: {event.src_path}")
            self._process_file(event.src_path)
    
    def _process_file(self, file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                html_content = f.read()
            
            doc = self.converter.convert_multiple_problems([html_content])
            
            output_name = Path(file_path).stem + '.docx'
            output_path = Path(self.output_folder) / output_name
            doc.save(str(output_path))
            
            print(f"変換完了: {output_path}")
        except Exception as e:
            print(f"エラー: {str(e)}")

def start_watching(input_folder, output_folder, converter, template='standard'):
    """フォルダ監視を開始"""
    event_handler = HTMLFileHandler(converter, output_folder, template)
    observer = Observer()
    observer.schedule(event_handler, input_folder, recursive=False)
    observer.start()
    
    print(f"監視開始: {input_folder}")
    print("Ctrl+Cで終了")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
成果物:

大量ファイルの一括処理
自動変換システム
ログ・エラー管理
Phase 5: AIエージェント統合（最終段階、1-2週間）
最後の段階では、LM StudioなどのAIモデルと統合し、問題生成から変換までの完全自動化を実現します。

実装する機能:

AI APIラッパーでは、LM StudioのAPIと通信し、構造化プロンプトを送信して問題HTMLを取得します。

Copy# ai_agent.py
import requests
import json

class AIAgent:
    def __init__(self, api_url="http://localhost:1234/v1/completions"):
        self.api_url = api_url
        self.prompt_templates = PROBLEM_GENERATION_PROMPT
    
    def generate_problem(self, difficulty='中級', category='方程式', count=1):
        """AIに問題生成を依頼"""
        prompt = self.prompt_templates.format(
            difficulty=difficulty,
            category=category,
            count=count
        )
        
        response = requests.post(
            self.api_url,
            json={
                "prompt": prompt,
                "max_tokens": 2000,
                "temperature": 0.7,
            }
        )
        
        if response.status_code == 200:
            result = response.json()
            html_content = result['choices'][0]['text']
            return self._validate_and_clean(html_content)
        else:
            raise Exception(f"API Error: {response.status_code}")
    
    def _validate_and_clean(self, html):
        """生成されたHTMLを検証・整形"""
        # 構造チェック
        # 不要な部分の削除
        # フォーマット修正
        return html
完全自動化パイプラインでは、問題生成→変換→出力の一連の流れを自動化します。

Copy# pipeline.py
class AutomatedPipeline:
    def __init__(self, ai_agent, converter, template_manager):
        self.ai = ai_agent
        self.converter = converter
        self.templates = template_manager
    
    def create_problem_set(self, config):
        """
        問題セットを自動生成
        
        config = {
            'problems': [
                {'difficulty': '初級', 'category': '方程式', 'count': 2},
                {'difficulty': '中級', 'category': '関数', 'count': 3},
            ],
            'template': 'exam',
            'output': 'test_001.docx'
        }
        """
        all_html = []
        
        for problem_spec in config['problems']:
            html = self.ai.generate_problem(**problem_spec)
            all_html.append(html)
        
        # Word文書生成
        doc = self.converter.convert_multiple_problems(all_html)
        self.templates.apply_template(doc, config['template'])
        doc.save(config['output'])
        
        return config['output']
成果物:

AI統合による完全自動生成
エンドツーエンドのパイプライン
カスタマイズ可能な問題セット作成
まとめ：実装の優先順位
この段階別実装により、以下の流れで確実にシステムを構築できます：

Phase 1-2（必須）: 基本的な変換機能と統一感の確保。これだけでも実用的なシステムが完成します。

Phase 3（推奨）: GUIとテンプレートにより使いやすさが大幅に向上します。

Phase 4（オプション）: 大量処理が必要な場合に追加します。

Phase 5（最終目標）: AI統合により完全自動化を実現しますが、Phase 1-3が安定してから取り組むことを推奨します。

各フェーズは独立して動作するため、段階的に開発・テストを進めることができます。最初はPhase 1-2に集中し、実際に使いながら必要な機能を追加していくアプローチが最も効率的です。